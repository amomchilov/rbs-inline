use RBS::AST::Members::MethodDefinition::Overload

module RBS
  module Inline
    module AST
      module Members
        type ruby = RubyDef | RubyAlias | RubyMixin | RubyAttr

        type rbs = RBSDef | RBSAlias | RBSAttr

        type t = ruby | rbs

        class Base
        end

        class RubyDef < Base
          attr_reader node: Prism::DefNode

          attr_reader comments: AnnotationParser::ParsingResult?

          def initialize: (Prism::DefNode, AnnotationParser::ParsingResult?) -> void

          def method_name: () -> Symbol

          def method_overloads: () -> Array[Overload]

          def method_type_annotations: () -> Array[Annotations::Assertion]

          def return_type: () -> Types::t?

          def var_type_hash: () -> Hash[Symbol, Types::t?]

          def method_annotations: () -> Array[RBS::AST::Annotation]
        end

        class RubyAlias < Base
          attr_reader node: Prism::AliasMethodNode

          attr_reader comments: AnnotationParser::ParsingResult?

          def initialize: (Prism::AliasMethodNode, AnnotationParser::ParsingResult?) -> void

          def old_name: () -> Symbol

          def new_name: () -> Symbol
        end

        class RubyMixin < Base
          attr_reader node: Prism::CallNode

          attr_reader comments: AnnotationParser::ParsingResult?

          attr_reader application: Annotations::Application?

          def initialize: (Prism::CallNode, AnnotationParser::ParsingResult?, Annotations::Application?) -> void

          def mixin_member: () -> TypeName

          def mixin_arguments: () -> Array[Types::t]
        end

        class RubyAttr < Base
        end

        class RBSDef < Base
        end

        class RBSAlias < Base
        end

        class RBSAttr < Base
        end
      end
    end
  end
end
