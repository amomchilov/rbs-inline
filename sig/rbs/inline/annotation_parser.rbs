module RBS
  module Inline
    class AnnotationParser
      # Group of consecutive comments, with detected annotations
      #
      class ParsingResult
        attr_reader comments: Array[Prism::Comment]
        attr_reader annotations: Array[AST::Annotations::t]
        attr_reader first_comment_offset: Integer

        def initialize: (Prism::Comment first_comment) -> void

        def line_range: () -> Range[Integer]

        def last_comment: () -> Prism::Comment

        # Add given comment to the result
        #
        # * Returns `self` if the comment can be added to the result
        # * Returns `nil` if not
        #
        def add_comment: (Prism::Comment) -> self?

        def lines: () -> Array[[String, Prism::Comment]]

        def content: () -> String
      end

      attr_reader input: Array[Prism::Comment]

      def self.parse: (Array[Prism::Comment]) -> Array[ParsingResult]

      def initialize: (Array[Prism::Comment]) -> void

      def parse: () -> Array[ParsingResult]

      class Tokenizer
        type token = [Symbol, String]

        attr_reader current_token: token?

        attr_reader scanner: StringScanner

        def initialize: (StringScanner) -> void

        # Returns next non-trivia token
        #
        # Trivia tokens are appended into the given tree.
        #
        def advance: (AST::Tree?) -> [Symbol, String]?

        def type?: (Symbol) -> bool

        def skip_to_comment: () -> String?
      end

      private

      def each_annotation_paragraph: (ParsingResult) { (Array[Prism::Comment]) -> void } -> void

      def parse_annotation: (AST::CommentLines) -> AST::Annotations::t?

      def parse_var_decl: (Tokenizer) -> AST::Tree

      def parse_type: (Tokenizer, AST::Tree parent_tree) -> (AST::Tree | Types::t | nil)

      def parse_comment: (Tokenizer) -> AST::Tree
    end
  end
end
